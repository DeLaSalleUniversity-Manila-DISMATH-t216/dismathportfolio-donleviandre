# dismathportfolio-donleviandre
dismathportfolio-donleviandre created by Classroom for GitHub

#WEEK 1

* This week, during the first day we were introduced to a different kind of mathematics, discrete mathematics.

* We Were introduced to some terms in this course and that this course doesn''t use numbers rather it uses logic and proof.

* We try an exercise on proving, which was the "knight and the knave".

* The exercise basically prepared us to what we should expect on this course.

* This week I also learned to identify a proposition and i was also introduced with logical connectives.

* After the explanation of the logical connectives, we were introduced to the truth table for Conjunction, Disjunction, Exclusive Disjunction, Conditional and Biconditional

* we also have a reading assignment which was to read the 1st chapter in the book about proofs

#WEEK 2

* This week we were introduced to logical equivalences that can used in simplifying a proposition.

* We were introduced to different laws these were: Identity Law, domination law, negation law, double negation law, idempotent law, commutative law, associative law, distibutive law, de morgan's law and the absorption law.

* After that we were introduced to rules of inference, namely: Modus ponens, Modus tollens, Hypothetical syllogism, Disjunctive syllogism, Addition, Simplication, Conjunction and Resolution	these are used to test the validty of the arguements given.

* I also learned about Existential Quantifiers which is only true for some values and Universal Quantifiers which is always true for any possible values.

* this week we also have a reading assignment nested quantifiers and rules of inference which is section 1.5 and 1.6 on the book.

#WEEK 3

* This week we were introduces to the diffrent methods of proof.

* The diffrent methods were: Direct proof, indirect proof, proof by contradiction, proof by contraposition, vacuous proof and trivial proof.

* I understand the explanation of the methods, but for me the tricky part is when to use such method, and i think i need to study about this more.

#WEEK 4

* This week we were also introduced to mathematical induction. it is a "mathematical proof technique, most commonly used to establish a given statement for all natural numbers, although it can be used to prove statements about any well-ordered set. It is a form of direct proof, and it is done in two steps. The first step, known as the base case, is to prove the given statement for the first natural number. The second step, known as the inductive step, is to prove that the given statement for any one natural number implies the given statement for the next natural number. From these two steps, mathematical induction is the rule from which we infer that the given statement is established for all natural numbers". -wikipedia

* We were also introduced with a new topic called recursive algorithm, it is defined as an algorithm that solves a problem by reducing it to an instance of the same problem with smaller input.

* It was also this week that we were refreshed to some topics like summation.

#WEEK 5

* This week we were introduced again to Recursive Algorithm and Program correctness

* we were also introduced with program correctness cause it is included in the first exam.

* i learned tht in order to for the program to be correct we need to prove that the program always gives the correct output. wee ned to verify the program using two steps, 1. Show Partial Correctness of program and 2. Show that program always terminates.

*  i also learned about hoare triple that we can use it prove if the program is true.

* i also learned that there are also rules of inference for program correctness, namely, Composition rule, conditional statement and if-else statement.

*  Zeno's Paradox and the Power Series were also introduced this week.

* Sets were introduced also this week.

* i laso learned the set operations or relationship between sets which are: Union,Intersection,Set Difference and,Symetric Difference.

#WEEK 6

* This week we were still on sets but a new term was introduced to us which was the cardinality, it is the the number of elements in a set or other grouping, as a property of that grouping.

* functions are introduced this week, A Function assigns to each element of a set, exactly one element of a related set 

* with functions we were taught how to identify the domain and codomain of a function.

* we were also taught of the Different types of Functions, namely, One-To-One Function, Onto Function , and Bijection.

* One-To-One Function; If and only if f(a)=f(b) implies that a=b for all a and b in the domain of f.

* Onto Function; If the range and domain are equal and that every member of the codomain is the image of some elementof the domain.

* Bijection; If it is both one-to-one and onto.

#WEEK 7

* NO CLASSES

#WEEK 8

* we discussed about algoruthms which is a finite set of precise instructions for performing a computation or for solving a problem.

* in algorithm the imporatance of input and output was introduced.

* we were also taught on how to get the index of a certain element; and there are two ways to do that the linear search and the binary search.

* linear search is Locating an item in a list by examining the sequence of list elements one at a time, starting at the beginning.

* binary search: 
  - The algorithm begins by comparing the target with the middle element.
  - If the middle element is strictly lower than the target, then the search proceeds with the upper half of the list.
  - Otherwise, the search proceeds with the lower half of the list (including the middle)
  - Repeat this process until we have a list of size 1.
  - If target is equal to the single element in the list, then the position is
returned.
  - Otherwise, -1 is returned to indicate that the element was not found
  
* greedy algorithm was also introduced to us it is used when problems minimize or maximize some parameter over all possible inputs

* and we were also introduced into how to sort number using bubble search and insertion sort

* bubble sort has the concept that the bigger the number it will float higher like a bubble while insertion sort is placing in order and inserting the element into the already sorted part of the set.

#WEEK 9

* after last weeks discussion about searching lagorithms this week we were introduced to a new topic about sorting algorithms.

* sorting algorithms are algorithms that sorts the given inputs by its value or sorting the ouputs by increasingly. It like alphabetizing words.

* there are two main sorting algorithms introduced to us: bubble sort and insertion sort
  - bubble sort is comparing one element to each of the other element. It is called bubble sort because it got its concept from bubbles; the larger bubble or the element with the largest value will float up and the least will remain at the bottom.
  - insertion sort compares a new element to an initial element and if it is greater it will be placed after otherwise before.

* This week we were also introduced with greedy algorithms.

  - Greedy algorithms is a type of algorithm that gets the optimul output for a certain problem. This type of algorithm is commonly used on optimation problems like find the least number of coins for the payment. 

#WEEK 10

* This week we learned about the growth of functions.

* growth of functions is a limit of a given function.

* growth of a function can be described or approximated using:

  - Big-O notation ( upper bound )
  - Big-Omega noation ( lower bound )
  - Big-Theta
  
* Big-O notation ( upper bound ): let f(x) and g(x) be functions; |f(x)| <= C|g(x)| whenever x>k

* Big-Omega notation ( lower bound ): let f(x) and g(x) be functions; C|g(x)| <= |f(x)| whenverr x>k. 

* Big-Theta notation ( both lower bound and upper bound ): let f(x) and g(x) be functions; C|g(x)| <= |f(x)| <= C|g(x)|

* this week we were also introdiced about time complexities; time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the string representing the input. 
  - it is also discussed in this topic the worst time complexity
    - which is defined as the maximum amount of time taken on any input of size n.

* Lastly we discussed about about division and modulo operator. which was used in cryptology or making the message hidden.

#WEEK 11

* NO CLASSES 

#WEEK 12

* Graph Theory was introduced this week. These are discrete structures consisting of vertices and edges that connect these vertices.

* graphs(G) are represented by G={ (V,E) }; where {V} is a set consisting of vertices and {E} is a set consisting of edges

* Degree of a vertex - this are the number of edges connected to a certain node or vertex.
  - loops; a loop is sometime found on a vertex, it is counted twice or has a degree of 2

* we were also introduced to the Handshaking Theorem, this used to count the number of edges in a graph.
  - formula: 2e=summation(degrees)(number of vertex)

* subgraph is a smaller graph that is a part taken from its original big graph.

* There are also simple special graphs:
  - complete graphs; is a simple graph that contains exactly one edge between each pair of vertices. it is represented by K.
  - cyle; consist of n vertices that forms a cycle. it is represented by C.
  - Wheels; it just like a cycle but there is an additional vertex that it placed on the middle and connects to every vertex on the cycle.

* walk through a graph: path and a circuit.
  - A path is a sequence of edges that begins at a vertex of a graph and travels from vertex to vertex along the edges of a graph.
  - circuit is like a path but it goes back to the vertex where you started.
  
* Euler Circuit is a walk wherein it covers all edges exactly once and goes back to the vertex where it started; exists whenever every vertex in the graph has even degree.

* Euler Path is a walk where all edges are covered once; exists whenever there are exactly two vertices with odd degree.

* Hamilton Circuit a walk where all nodes are covered once a you return to the vertex where you started from.

* Hamilton path is a walk where all nodes are covered once.

* Pendant is a one degree node.

* isolated node has a degree of zero and is disconnected from the graph

* Adjacency Matrix - to put a graph into a matrix by identifying presence of an edge between vertices

* Incidence Matrix - matrix between edges and vertices

* Isomorphism equivalence between two graphs

* Two graphs are isomorphic whenever:
  - when the two graphs have equal number of edges.
  - when the two graphs have equal number of vertices
  - when the two graph have equal number of nodes having the same number of degrees per node

* Planar graph is a graph where no edges intersect.

* Euler Formula: r = e - v + 2, where r is the number of regions formed by a graph.

* Kuratowski's Theorem states that a graph is non-planar if and only if it contains a homeomorphic subgraph that is k3,3 or k5.
  - you can have a homeographic subgraph by using elementary subdivision on the main graph.
  - elementary subdivision is a way of manipulating the main graph by eliminating an edge and place a new node on that edge. thus edge AB will be now be edge AC,CB adding a node C in between.
  
#WEEK 13

* This week we are still on graphs, a new topic about graphs was introduced to us which is graph coloring.
  - graph coloring is assigning a color to a node or vertex so that no adjacent nodes will have the same color.

* in graph coloring there is a " 4 color theorem ". which states that if you have a planar graph the maximum number of colors you can have will only be 4.

* number of colors for simple special graphs
  - in a complete graph(K) ; the number of colors is the same as the number of nodes.
  - in a cycle(C):
    - if the nodes are odd there will be 3 colors 
    - if the nodes are even there will be 2 colors
  - in a wheel(W):
    - if the nodes are odd there will be 4 colors
    - if the nodes are even there will 3 colors

* This week we also discussed abou trees.
  - a tree is a connected undirected graph with no simple circuits
  - it is a data structure that emulates a heirarchal tree structure with a set of linked nodes

* rooted tree a tree in which one of the vertex has been designated as the root and every edge is directed away from the root.
  - in a tree you can identify the:
    - parent 
    - children
    - sibling
    - ancestors 
    - descendants
    - internal vertices
    - leaves

* M-ary root tree
  - a tree is m-ary if every internal vertex has no more than m children
  - a tree is called a full m-ary tree if every internal vertex has the same number of children
  - when m=2 it is called a binary tree.

* ordered rooted tree if the chldren of each internal vertex is ordered

* language and grammars were the last topic

* in programming the syntax or the grammar is vital. Syntax is the form of a formal language. A derivation tree may be used to check validity of the grammar.

* Automata theory studies the laws of computation.

* Finite Automaton provides the simplest model of computing device, based on the concept of states.

* Lexical analysis is the process where the stream of characters making up the source program is read from left to right and grouped into tokens.
* Finite-state machine: M = {S, I, O, f, g, s(0)} with S-states, I-input, O-output, f-function, g-function output and s(0)-initial state.

#WEEK 14 

* FINALS WEEK
